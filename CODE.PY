import tkinter as tk
from tkinter import ttk
import time

class SafetySimulator:
    # --- ìƒìˆ˜ ì •ì˜ ---
    SURFACE_Y = 20
    CANVAS_WIDTH = 600
    CANVAS_HEIGHT = 400
    SCALE_FACTOR = 8  # 1ë¯¸í„°ë‹¹ í”½ì…€ ìˆ˜
    UPDATE_INTERVAL = 50  # ms
    TIMELINE_HEIGHT = 60
    
    def __init__(self, root):
        self.root = root
        self.root.title("Freediving Safety Buddy Simulator")
        self.root.geometry("650x800")

        # --- ë³€ìˆ˜ ì´ˆê¸°í™” ---
        self.is_running = False
        self.is_paused = False
        self.sim_speed = 1.0
        self.last_update_time = 0
        
        # ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ (ì‹¤ì œ ì‹œê°„ê³¼ ë¶„ë¦¬)
        self.current_sim_time = 0.0
        self.total_dive_time = 0.0
        
        # ë‹¤ì´ë²„/ì„¸ì´í”„í‹° ê¹Šì´
        self.diver_depth = 0.0
        self.safety_depth = 0.0
        
        # ìºì‹œëœ ì…ë ¥ê°’
        self.cached_target = 40.0
        self.cached_meet = 15.0
        self.cached_diver_speed = 1.0
        self.cached_safety_speed = 1.0
        
        # íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ì‹œê°„
        self.turn_time = 0.0
        self.safety_start_time = 0.0
        self.meeting_time = 0.0
        
        # ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ìƒíƒœ
        self.is_seeking = False

        # --- UI ë ˆì´ì•„ì›ƒ ---
        self.create_widgets()
        
        # ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸°
        self.draw_scene()
        
        # ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘
        self.update_simulation()

    def create_widgets(self):
        # 1. ì„¤ì • íŒ¨ë„ (Input Frame)
        control_frame = ttk.LabelFrame(self.root, text="Dive Plan Settings")
        control_frame.pack(fill="x", padx=10, pady=5)

        # ê·¸ë¦¬ë“œ ì„¤ì •
        ttk.Label(control_frame, text="Target Depth (m):").grid(row=0, column=0, padx=5, pady=5)
        self.entry_target = ttk.Entry(control_frame, width=10)
        self.entry_target.insert(0, "40")
        self.entry_target.grid(row=0, column=1)

        ttk.Label(control_frame, text="Meeting Depth (m):").grid(row=0, column=2, padx=5, pady=5)
        self.entry_meet = ttk.Entry(control_frame, width=10)
        self.entry_meet.insert(0, "15")
        self.entry_meet.grid(row=0, column=3)

        ttk.Label(control_frame, text="Diver Speed (m/s):").grid(row=1, column=0, padx=5, pady=5)
        self.entry_diver_speed = ttk.Entry(control_frame, width=10)
        self.entry_diver_speed.insert(0, "1.0")
        self.entry_diver_speed.grid(row=1, column=1)

        ttk.Label(control_frame, text="Safety Speed (m/s):").grid(row=1, column=2, padx=5, pady=5)
        self.entry_safety_speed = ttk.Entry(control_frame, width=10)
        self.entry_safety_speed.insert(0, "1.0")
        self.entry_safety_speed.grid(row=1, column=3)
        
        # ë°°ì† ì„¤ì •
        ttk.Label(control_frame, text="Sim Speed (x):").grid(row=2, column=0, padx=5, pady=5)
        self.entry_sim_speed = ttk.Entry(control_frame, width=10)
        self.entry_sim_speed.insert(0, "1.0")
        self.entry_sim_speed.grid(row=2, column=1)

        # ë²„íŠ¼
        self.btn_start = ttk.Button(control_frame, text="â–¶ Start", command=self.start_sim, width=12)
        self.btn_start.grid(row=3, column=0, pady=10, padx=5)
        
        self.btn_pause = ttk.Button(control_frame, text="â¸ Pause", command=self.toggle_pause, width=12, state="disabled")
        self.btn_pause.grid(row=3, column=1, pady=10, padx=5)
        
        self.btn_reset = ttk.Button(control_frame, text="â¹ Reset", command=self.reset_sim, width=12)
        self.btn_reset.grid(row=3, column=2, pady=10, padx=5)

        # 2. ì •ë³´ íŒ¨ë„ (Info Frame)
        info_frame = ttk.LabelFrame(self.root, text="Calculation & Status")
        info_frame.pack(fill="x", padx=10, pady=5)
        
        self.lbl_calc = ttk.Label(info_frame, text="ê³„ì‚° ê²°ê³¼ ëŒ€ê¸° ì¤‘...", foreground="blue")
        self.lbl_calc.pack(pady=5)
        
        self.lbl_timer = ttk.Label(info_frame, text="Dive Time: 0.0s / 0.0s", font=("Arial", 12, "bold"))
        self.lbl_timer.pack(pady=5)
        
        self.lbl_status = ttk.Label(info_frame, text="", font=("Arial", 10))
        self.lbl_status.pack(pady=2)

        # 3. íƒ€ì„ë¼ì¸ íŒ¨ë„
        timeline_frame = ttk.LabelFrame(self.root, text="Timeline")
        timeline_frame.pack(fill="x", padx=10, pady=5)
        
        # íƒ€ì„ë¼ì¸ ìº”ë²„ìŠ¤ (ì´ë²¤íŠ¸ ë§ˆì»¤ í‘œì‹œ)
        self.timeline_canvas = tk.Canvas(timeline_frame, bg="white", height=self.TIMELINE_HEIGHT)
        self.timeline_canvas.pack(fill="x", padx=5, pady=5)
        
        # íƒ€ì„ë¼ì¸ ìŠ¬ë¼ì´ë”
        self.timeline_var = tk.DoubleVar(value=0)
        self.timeline_slider = ttk.Scale(
            timeline_frame, 
            from_=0, 
            to=100, 
            orient="horizontal",
            variable=self.timeline_var,
            command=self.on_timeline_change
        )
        self.timeline_slider.pack(fill="x", padx=5, pady=5)
        
        # ìŠ¬ë¼ì´ë” ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        self.timeline_slider.bind("<ButtonPress-1>", self.on_seek_start)
        self.timeline_slider.bind("<ButtonRelease-1>", self.on_seek_end)
        
        # í€µ ì í”„ ë²„íŠ¼
        jump_frame = ttk.Frame(timeline_frame)
        jump_frame.pack(fill="x", padx=5, pady=5)
        
        self.btn_jump_start = ttk.Button(jump_frame, text="â® ì‹œì‘", command=lambda: self.jump_to_time(0), width=10)
        self.btn_jump_start.pack(side="left", padx=2)
        
        self.btn_jump_turn = ttk.Button(jump_frame, text="ğŸ”„ í„´", command=self.jump_to_turn, width=10)
        self.btn_jump_turn.pack(side="left", padx=2)
        
        self.btn_jump_safety = ttk.Button(jump_frame, text="ğŸŠ ì„¸ì´í”„í‹° ì¶œë°œ", command=self.jump_to_safety_start, width=12)
        self.btn_jump_safety.pack(side="left", padx=2)
        
        self.btn_jump_meet = ttk.Button(jump_frame, text="ğŸ¤ ë¯¸íŒ…", command=self.jump_to_meeting, width=10)
        self.btn_jump_meet.pack(side="left", padx=2)
        
        self.btn_jump_end = ttk.Button(jump_frame, text="â­ ì¢…ë£Œ", command=self.jump_to_end, width=10)
        self.btn_jump_end.pack(side="left", padx=2)

        # 4. ì‹œê°í™” ìº”ë²„ìŠ¤ (Canvas)
        self.canvas = tk.Canvas(self.root, bg="alice blue", height=self.CANVAS_HEIGHT)
        self.canvas.pack(fill="both", expand=True, padx=10, pady=10)

    def validate_inputs(self):
        """ì…ë ¥ê°’ ìœ íš¨ì„± ê²€ì‚¬"""
        try:
            target = float(self.entry_target.get())
            meet = float(self.entry_meet.get())
            d_speed = float(self.entry_diver_speed.get())
            s_speed = float(self.entry_safety_speed.get())
            sim_speed = float(self.entry_sim_speed.get())
            
            errors = []
            
            if target <= 0:
                errors.append("ëª©í‘œ ìˆ˜ì‹¬ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
            if meet <= 0:
                errors.append("ë¯¸íŒ… ìˆ˜ì‹¬ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
            if target <= meet:
                errors.append("ëª©í‘œ ìˆ˜ì‹¬ì´ ë¯¸íŒ… ìˆ˜ì‹¬ë³´ë‹¤ ê¹Šì–´ì•¼ í•©ë‹ˆë‹¤")
            if d_speed <= 0:
                errors.append("ë‹¤ì´ë²„ ì†ë„ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
            if s_speed <= 0:
                errors.append("ì„¸ì´í”„í‹° ì†ë„ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
            if sim_speed <= 0:
                errors.append("ì‹œë®¬ë ˆì´ì…˜ ë°°ì†ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
            
            if errors:
                self.lbl_calc.config(text=f"Error: {errors[0]}", foreground="red")
                return False
            
            # ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì‹œ ê°’ ìºì‹œ
            self.cached_target = target
            self.cached_meet = meet
            self.cached_diver_speed = d_speed
            self.cached_safety_speed = s_speed
            self.sim_speed = sim_speed
            
            return True
            
        except ValueError:
            self.lbl_calc.config(text="Error: ëª¨ë“  í•„ë“œì— ìˆ«ìë¥¼ ì •í™•íˆ ì…ë ¥í•´ì£¼ì„¸ìš”.", foreground="red")
            return False

    def calculate_plan(self):
        """ë‹¤ì´ë¸Œ ê³„íš ë° íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ê³„ì‚°"""
        target = self.cached_target
        meet = self.cached_meet
        d_speed = self.cached_diver_speed
        s_speed = self.cached_safety_speed
        
        # íƒ€ì„ë¼ì¸ ì´ë²¤íŠ¸ ì‹œê°„ ê³„ì‚°
        self.turn_time = target / d_speed
        diver_ascent_to_meet_time = (target - meet) / d_speed
        self.meeting_time = self.turn_time + diver_ascent_to_meet_time
        
        # ì„¸ì´í”„í‹° ì¶œë°œ ì‹œê°„
        safety_time_to_meet = meet / s_speed
        self.safety_start_time = self.meeting_time - safety_time_to_meet
        
        # ì „ì²´ ë‹¤ì´ë¸Œ ì‹œê°„ (ìˆ˜ë©´ ë„ì°©)
        self.total_dive_time = self.turn_time + (target / d_speed)
        
        # ìŠ¬ë¼ì´ë” ë²”ìœ„ ì„¤ì •
        self.timeline_slider.config(to=self.total_dive_time)
        
        # í„´ íƒ€ì„ ê¸°ì¤€ ëŒ€ê¸° ì‹œê°„
        wait_after_turn = self.safety_start_time - self.turn_time
        
        self.lbl_calc.config(
            text=f"[ê³„ì‚° ê²°ê³¼] ì„¸ì´í”„í‹° ì¶œë°œ: {self.safety_start_time:.1f}ì´ˆ | "
                 f"í„´: {self.turn_time:.1f}ì´ˆ | ë¯¸íŒ…: {self.meeting_time:.1f}ì´ˆ | "
                 f"ì´: {self.total_dive_time:.1f}ì´ˆ",
            foreground="blue"
        )
        
        self.draw_timeline()

    def calculate_positions_at_time(self, t):
        """íŠ¹ì • ì‹œê°„ì—ì„œì˜ ë‹¤ì´ë²„/ì„¸ì´í”„í‹° ìœ„ì¹˜ ê³„ì‚°"""
        target = self.cached_target
        meet = self.cached_meet
        d_speed = self.cached_diver_speed
        s_speed = self.cached_safety_speed
        
        # ë‹¤ì´ë²„ ìœ„ì¹˜
        if t <= self.turn_time:
            # í•˜ê°• ì¤‘
            diver_depth = d_speed * t
        else:
            # ìƒìŠ¹ ì¤‘
            ascent_time = t - self.turn_time
            diver_depth = target - (d_speed * ascent_time)
            diver_depth = max(0, diver_depth)
        
        # ì„¸ì´í”„í‹° ìœ„ì¹˜
        if t < self.safety_start_time:
            safety_depth = 0
        elif t < self.safety_start_time + (meet / s_speed):
            # í•˜ê°• ì¤‘
            descent_time = t - self.safety_start_time
            safety_depth = s_speed * descent_time
        else:
            # ë¯¸íŒ… ì§€ì  ë„ë‹¬ í›„
            safety_depth = meet
            # ë‹¤ì´ë²„ê°€ ë¯¸íŒ… ì§€ì  ì§€ë‚˜ë©´ í•¨ê»˜ ìƒìŠ¹
            if diver_depth < meet:
                safety_depth = diver_depth
        
        return diver_depth, safety_depth

    def get_status_at_time(self, t):
        """íŠ¹ì • ì‹œê°„ì—ì„œì˜ ìƒíƒœ ë¬¸ìì—´"""
        if t <= 0:
            return "ğŸŠ ì¤€ë¹„..."
        elif t < self.turn_time:
            return "ğŸŠ ë‹¤ì´ë²„ í•˜ê°• ì¤‘..."
        elif t < self.turn_time + 0.5:
            return "ğŸ”„ ë‹¤ì´ë²„ í„´!"
        elif t < self.safety_start_time:
            return "â¬†ï¸ ë‹¤ì´ë²„ ìƒìŠ¹ ì¤‘ (ì„¸ì´í”„í‹° ëŒ€ê¸°)"
        elif t < self.safety_start_time + (self.cached_meet / self.cached_safety_speed):
            return "ğŸŠ ì„¸ì´í”„í‹° í•˜ê°• ì¤‘!"
        elif t < self.meeting_time:
            return "â³ ì„¸ì´í”„í‹° ë¯¸íŒ… ì§€ì  ëŒ€ê¸°"
        elif t < self.total_dive_time:
            return "âœ… ë¯¸íŒ… ì„±ê³µ! í•¨ê»˜ ìƒìŠ¹ ì¤‘"
        else:
            return "ğŸ‰ ë‹¤ì´ë¸Œ ì™„ë£Œ!"

    def draw_timeline(self):
        """íƒ€ì„ë¼ì¸ ìº”ë²„ìŠ¤ì— ì´ë²¤íŠ¸ ë§ˆì»¤ ê·¸ë¦¬ê¸°"""
        self.timeline_canvas.delete("all")
        
        if self.total_dive_time <= 0:
            return
        
        canvas_width = self.timeline_canvas.winfo_width()
        if canvas_width < 10:
            canvas_width = 600
        
        padding = 20
        usable_width = canvas_width - (padding * 2)
        
        # ë°°ê²½ ë°”
        self.timeline_canvas.create_rectangle(
            padding, 25, canvas_width - padding, 35, 
            fill="#e0e0e0", outline=""
        )
        
        # í˜„ì¬ ì§„í–‰ ë°”
        if self.total_dive_time > 0:
            progress = self.current_sim_time / self.total_dive_time
            progress = min(1, max(0, progress))
            progress_x = padding + (usable_width * progress)
            self.timeline_canvas.create_rectangle(
                padding, 25, progress_x, 35, 
                fill="#4CAF50", outline=""
            )
        
        # ì´ë²¤íŠ¸ ë§ˆì»¤ í•¨ìˆ˜
        def draw_marker(time_val, color, label, y_offset=0):
            if time_val > self.total_dive_time:
                return
            x = padding + (usable_width * (time_val / self.total_dive_time))
            self.timeline_canvas.create_line(x, 20, x, 40, fill=color, width=2)
            self.timeline_canvas.create_oval(x-4, 26, x+4, 34, fill=color, outline="")
            self.timeline_canvas.create_text(x, 50 + y_offset, text=label, font=("Arial", 8), fill=color)
        
        # ì´ë²¤íŠ¸ ë§ˆì»¤
        draw_marker(0, "blue", f"ì‹œì‘\n0s")
        draw_marker(self.turn_time, "purple", f"í„´\n{self.turn_time:.1f}s")
        draw_marker(self.safety_start_time, "orange", f"ì„¸ì´í”„í‹°\n{self.safety_start_time:.1f}s")
        draw_marker(self.meeting_time, "green", f"ë¯¸íŒ…\n{self.meeting_time:.1f}s")
        draw_marker(self.total_dive_time, "red", f"ì¢…ë£Œ\n{self.total_dive_time:.1f}s")
        
        # í˜„ì¬ ìœ„ì¹˜ ë§ˆì»¤
        if self.total_dive_time > 0:
            current_x = padding + (usable_width * (self.current_sim_time / self.total_dive_time))
            self.timeline_canvas.create_polygon(
                current_x - 6, 15, current_x + 6, 15, current_x, 23,
                fill="#2196F3", outline=""
            )

    def draw_scene(self):
        """ë©”ì¸ ì‹œë®¬ë ˆì´ì…˜ ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°"""
        self.canvas.delete("all")
        
        target = self.cached_target
        meet = self.cached_meet
        
        # ê¸°ë³¸ ë¼ì¸ ë° ìˆ˜ì‹¬ ëˆˆê¸ˆ
        self.canvas.create_line(0, self.SURFACE_Y, self.CANVAS_WIDTH, self.SURFACE_Y, fill="blue", width=2)
        self.canvas.create_text(self.CANVAS_WIDTH - 50, 10, text="Surface (0m)")
        
        max_depth_display = target + 10
        center_x = self.CANVAS_WIDTH // 2
        
        # ê°€ì´ë“œ ë¡œí”„
        rope_end_y = self.SURFACE_Y + max_depth_display * self.SCALE_FACTOR
        self.canvas.create_line(center_x, self.SURFACE_Y, center_x, rope_end_y, fill="gray", dash=(4, 2))

        # ëª©í‘œ ìˆ˜ì‹¬ í‘œì‹œ
        target_y = self.SURFACE_Y + target * self.SCALE_FACTOR
        self.canvas.create_line(center_x - 20, target_y, center_x + 20, target_y, fill="red", width=3)
        self.canvas.create_text(center_x + 50, target_y, text=f"Target: {target:.0f}m")

        # ë¯¸íŒ… ìˆ˜ì‹¬ í‘œì‹œ
        meet_y = self.SURFACE_Y + meet * self.SCALE_FACTOR
        self.canvas.create_line(center_x - 15, meet_y, center_x + 15, meet_y, fill="green", width=2, dash=(2, 2))
        self.canvas.create_text(center_x + 50, meet_y, text=f"Meet: {meet:.0f}m", fill="green")

        # ìˆ˜ì‹¬ ëˆˆê¸ˆ (10m ë‹¨ìœ„)
        for depth in range(10, int(max_depth_display), 10):
            y = self.SURFACE_Y + depth * self.SCALE_FACTOR
            self.canvas.create_line(center_x - 5, y, center_x + 5, y, fill="lightgray")
            self.canvas.create_text(center_x - 25, y, text=f"{depth}m", fill="gray", font=("Arial", 8))

        # ë‹¤ì´ë²„ ê·¸ë¦¬ê¸°
        diver_pixel_y = self.SURFACE_Y + self.diver_depth * self.SCALE_FACTOR
        self.canvas.create_oval(
            center_x - 10, diver_pixel_y - 10, 
            center_x + 10, diver_pixel_y + 10, 
            fill="blue", outline="darkblue", width=2
        )
        self.canvas.create_text(
            center_x - 40, diver_pixel_y, 
            text=f"Diver\n{self.diver_depth:.1f}m", 
            font=("Arial", 9, "bold"), fill="blue"
        )

        # ì„¸ì´í”„í‹° ê·¸ë¦¬ê¸°
        safety_pixel_y = self.SURFACE_Y + self.safety_depth * self.SCALE_FACTOR
        offset_x = 40
        self.canvas.create_oval(
            center_x + offset_x - 10, safety_pixel_y - 10, 
            center_x + offset_x + 10, safety_pixel_y + 10, 
            fill="orange", outline="darkorange", width=2
        )
        self.canvas.create_text(
            center_x + offset_x + 40, safety_pixel_y, 
            text=f"Safety\n{self.safety_depth:.1f}m", 
            font=("Arial", 9, "bold"), fill="darkorange"
        )

    def set_inputs_state(self, state):
        """ì…ë ¥ í•„ë“œ í™œì„±í™”/ë¹„í™œì„±í™”"""
        self.entry_target.config(state=state)
        self.entry_meet.config(state=state)
        self.entry_diver_speed.config(state=state)
        self.entry_safety_speed.config(state=state)
        self.entry_sim_speed.config(state=state)

    def start_sim(self):
        if self.is_running and self.is_paused:
            # ì¼ì‹œì •ì§€ ìƒíƒœì—ì„œ ì¬ì‹œì‘
            self.toggle_pause()
            return
            
        if not self.validate_inputs():
            return
        
        self.calculate_plan()
        self.current_sim_time = 0.0
        self.diver_depth = 0.0
        self.safety_depth = 0.0
        
        self.set_inputs_state("disabled")
        self.btn_start.config(text="â–¶ Resume", state="disabled")
        self.btn_pause.config(state="normal")
        
        self.is_running = True
        self.is_paused = False
        self.last_update_time = time.time()

    def toggle_pause(self):
        """ì¼ì‹œì •ì§€/ì¬ê°œ"""
        if not self.is_running:
            return
            
        self.is_paused = not self.is_paused
        
        if self.is_paused:
            self.btn_pause.config(text="â–¶ Resume")
            self.btn_start.config(state="normal")
        else:
            self.btn_pause.config(text="â¸ Pause")
            self.btn_start.config(state="disabled")
            self.last_update_time = time.time()

    def reset_sim(self):
        self.is_running = False
        self.is_paused = False
        self.current_sim_time = 0.0
        self.diver_depth = 0.0
        self.safety_depth = 0.0
        
        self.set_inputs_state("normal")
        self.btn_start.config(text="â–¶ Start", state="normal")
        self.btn_pause.config(text="â¸ Pause", state="disabled")
        
        self.timeline_var.set(0)
        self.draw_scene()
        self.draw_timeline()
        self.lbl_timer.config(text="Dive Time: 0.0s / 0.0s")
        self.lbl_status.config(text="")
        self.lbl_calc.config(text="ê³„ì‚° ê²°ê³¼ ëŒ€ê¸° ì¤‘...", foreground="blue")

    def on_timeline_change(self, value):
        """ìŠ¬ë¼ì´ë” ê°’ ë³€ê²½ ì‹œ"""
        if self.is_seeking and self.total_dive_time > 0:
            self.jump_to_time(float(value))

    def on_seek_start(self, event):
        """ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì‹œì‘"""
        self.is_seeking = True
        if self.is_running and not self.is_paused:
            self.toggle_pause()

    def on_seek_end(self, event):
        """ìŠ¬ë¼ì´ë” ë“œë˜ê·¸ ì¢…ë£Œ"""
        self.is_seeking = False

    def jump_to_time(self, t):
        """íŠ¹ì • ì‹œê°„ìœ¼ë¡œ ì í”„"""
        if self.total_dive_time <= 0:
            # ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ì „ì´ë©´ ë¨¼ì € ê³„ì‚°
            if not self.validate_inputs():
                return
            self.calculate_plan()
            self.is_running = True
            self.is_paused = True
            self.set_inputs_state("disabled")
            self.btn_start.config(text="â–¶ Resume", state="normal")
            self.btn_pause.config(text="â–¶ Resume", state="normal")
        
        t = max(0, min(t, self.total_dive_time))
        self.current_sim_time = t
        self.diver_depth, self.safety_depth = self.calculate_positions_at_time(t)
        
        self.timeline_var.set(t)
        self.update_display()

    def jump_to_turn(self):
        """í„´ ì‹œì ìœ¼ë¡œ ì í”„"""
        self.jump_to_time(self.turn_time)

    def jump_to_safety_start(self):
        """ì„¸ì´í”„í‹° ì¶œë°œ ì‹œì ìœ¼ë¡œ ì í”„"""
        self.jump_to_time(self.safety_start_time)

    def jump_to_meeting(self):
        """ë¯¸íŒ… ì‹œì ìœ¼ë¡œ ì í”„"""
        self.jump_to_time(self.meeting_time)

    def jump_to_end(self):
        """ì¢…ë£Œ ì‹œì ìœ¼ë¡œ ì í”„"""
        self.jump_to_time(self.total_dive_time)

    def update_display(self):
        """í™”ë©´ ì—…ë°ì´íŠ¸"""
        self.lbl_timer.config(text=f"Dive Time: {self.current_sim_time:.1f}s / {self.total_dive_time:.1f}s")
        self.lbl_status.config(text=self.get_status_at_time(self.current_sim_time), foreground="darkblue")
        self.draw_scene()
        self.draw_timeline()

    def update_simulation(self):
        """ë©”ì¸ ì—…ë°ì´íŠ¸ ë£¨í”„"""
        if self.is_running and not self.is_paused and not self.is_seeking:
            current_time = time.time()
            delta = (current_time - self.last_update_time) * self.sim_speed
            self.last_update_time = current_time
            
            # ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ ì¦ê°€
            self.current_sim_time += delta
            
            # ì¢…ë£Œ ì²´í¬
            if self.current_sim_time >= self.total_dive_time:
                self.current_sim_time = self.total_dive_time
                self.is_running = False
                self.set_inputs_state("normal")
                self.btn_start.config(text="â–¶ Start", state="normal")
                self.btn_pause.config(state="disabled")
            
            # ìœ„ì¹˜ ê³„ì‚°
            self.diver_depth, self.safety_depth = self.calculate_positions_at_time(self.current_sim_time)
            
            # ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            self.timeline_var.set(self.current_sim_time)
            
            self.update_display()
        
        self.root.after(self.UPDATE_INTERVAL, self.update_simulation)


if __name__ == "__main__":
    root = tk.Tk()
    app = SafetySimulator(root)
    root.mainloop()
